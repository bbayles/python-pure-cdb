#!/usr/bin/env python
import filecmp
import hashlib
import io
import os.path
import shutil
import tempfile
import unittest

import cdblib

from cdblib.cdbmake import main as python_pure_cdbmake
from cdblib.cdbdump import main as python_pure_cdbdump

from .cdblib_test import testdata_path

TYPES_DATA = (
    b'+6,1:binary->\x81\n'
    b'+4,4:text->\xf0\x9f\x95\xb4\n'
    b'+7,6:integer->102010\n'
    b'+7,3:integer->241\n'
    b'\n'
)


class ScriptsTests(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_cdbmake_known_hash(self):
        # Construct a database from text records and compare the resultant
        # file to what is generated by the official cdbmake tool
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        # `<out.cdb cdbdump | md5sum` produced the control
        self.assertEqual(
            output_hash.hexdigest(), 'dcc8b6502bcb648a71a6a080409312bb'
        )

    def _cdbmake_invalid(self, stdin, record_number, expected_error):
        stderr = io.StringIO()
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]

        with self.assertRaises(SystemExit):
            python_pure_cdbmake(args, stdin=stdin, stderr=stderr)

        error_msg = stderr.getvalue().lower()
        self.assertIn('record {}'.format(record_number), error_msg)
        self.assertIn(expected_error, error_msg)

    def test_cdbmake_invalid_start(self):
        # Records must start with +
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'-2,2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid start')

    def test_cdbmake_invalid_klen(self):
        # Key length must be terminated by ,
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2;2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid klen')

        # Key length must be an integer
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+0b,2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid klen')

    def test_cdbmake_invalid_separator(self):
        # Key and data must be separated by ->
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa>>bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid separator')

    def test_cdbmake_invalid_dlen(self):
        # Data length must be terminated by :
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2;aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid dlen')

    def test_cdbmake_short_record(self):
        # File cuts off before data
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa->b'
        )
        self._cdbmake_invalid(stdin, 2, 'did not match given length')

    def test_cdbmake_long_record(self):
        # Data too long - should have newline
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa->bbb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid character')

    def test_cdbmake_weird(self):
        # Records can have a newline
        stdin = io.BytesIO(
            b'+2,2:,:->:,\n'
            b'+2,2:->-><-\n'
            b'+7,7:newline->123\n'
            b'567\n'
            b'+2,2:\0+->+\0\n'
            b'\n'
        )
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]

        python_pure_cdbmake(args, stdin=stdin)

        with open(cdb_path, 'rb') as infile:
            data = infile.read()

        reader = cdblib.Reader(data)
        self.assertEqual(reader[b',:'], b':,')
        self.assertEqual(reader[b'->'], b'<-')
        self.assertEqual(reader[b'newline'], b'123\n567')
        self.assertEqual(reader[b'\0+'], b'+\0')

    def test_cdbmake_64_bits(self):
        # Construct a 64-bit database with the CLI tool and read back the
        # records
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp_64.cdb')
        args = ['-64', cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        # Ensure that everything can be decoded properly
        with open(cdb_path, 'rb') as infile:
            data = infile.read()

        reader = cdblib.Reader64(data)
        self.assertEqual(reader[b'binary'], b'\x81')
        self.assertEqual(reader.getstring(b'text'), u'\U0001f574')
        self.assertEqual(list(reader.getints(b'integer')), [102010, 241])

    def test_cdbdump_known_hash(self):
        # Dump a pre-made file to text and compare the output to what
        # is given by the official cdbdump tool
        top250_path = testdata_path('top250pws.cdb')
        with open(top250_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump([], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        # `<top250pws.cdb cdbdump | md5sum` produced the control
        output_hash = hashlib.md5()
        output_hash.update(data)
        self.assertEqual(
            output_hash.hexdigest(), '0564adfe4667506a326ba2f363415616'
        )

    def test_cdbdump_64_bits(self):
        # Construct a 64-bit database and then read it back with the CLI
        # tool. Since the cdbdump is text, the 64-bit database should
        # produce the same input as the 32-bit database
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        with open(cdb_path, 'wb') as outfile:
            writer = cdblib.Writer64(outfile)
            writer.put(b'binary', b'\x81')
            writer.putstring(b'text', u'\U0001f574')
            writer.putint(b'integer', 102010)
            writer.putint(b'integer', 241)
            writer.finalize()

        with open(cdb_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump(['-64'], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        self.assertEqual(data, TYPES_DATA)

    def _dump_then_make(self, path_to_dump, use_64=False):
        # Feeding a file into python-pure-cdbump produces a stream, which
        # can be fed into python-pure-cdbmake. The result should be an
        # identical file.
        dump_args = ['-64'] if use_64 else []

        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        make_args = ['-64'] if use_64 else []
        make_args += [cdb_path, tmp_path]

        with open(path_to_dump, 'rb') as dump_in:
            with io.BytesIO() as dump_out:
                python_pure_cdbdump(dump_args, stdin=dump_in, stdout=dump_out)
                dump_out.seek(0)
                python_pure_cdbmake(make_args, stdin=dump_out)

        self.assertTrue(filecmp.cmp(path_to_dump, cdb_path, shallow=False))

    def test_dump_then_make(self):
        self._dump_then_make(testdata_path('top250pws.cdb'))

    def test_dump_then_make_64(self):
        self._dump_then_make(testdata_path('top250pws.cdb64'), use_64=True)

    def _make_then_dump(self, use_64=False):
        # Feeding a stream into python-pure-cdbmake produces a file, which can
        # be fed into python-pure-cdbdump. The result should be an identical
        # stream.
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        make_args = ['-64'] if use_64 else []
        make_args += [cdb_path, tmp_path]

        dump_args = ['-64'] if use_64 else []

        with io.BytesIO(TYPES_DATA) as make_in:
            python_pure_cdbmake(make_args, stdin=make_in)

        with open(cdb_path, 'rb') as dump_in:
            with io.BytesIO() as dump_out:
                python_pure_cdbdump(dump_args, stdin=dump_in, stdout=dump_out)
                data = dump_out.getvalue()

        self.assertEqual(data, TYPES_DATA)

    def test_make_then_dump(self):
        self._make_then_dump()

    def test_make_then_dump_64(self):
        self._make_then_dump(use_64=True)


if __name__ == '__main__':
    unittest.main()
