#!/usr/bin/env python
from __future__ import unicode_literals

import hashlib
import io
import os.path
import shutil
import tempfile
import unittest

import cdblib

from cdblib.cdbmake import main as python_pure_cdbmake
from cdblib.cdbdump import main as python_pure_cdbdump

from .cdblib_test import testdata_path

TYPES_DATA = (
    b'+6,1:binary->\x81\n'
    b'+4,4:text->\xf0\x9f\x95\xb4\n'
    b'+7,6:integer->102010\n'
    b'+7,3:integer->241\n'
    b'\n'
)


class ScriptsTests(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_cdbmake_known_hash(self):
        # Construct a database from text records and compare the resultant
        # file to what is generated by the official cdbmake tool
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        # `<out.cdb cdbdump | md5sum` produced the control
        self.assertEqual(
            output_hash.hexdigest(), 'dcc8b6502bcb648a71a6a080409312bb'
        )

    def _cdbmake_invalid(self, stdin, record_number, expected_error):
        stderr = io.StringIO()
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]

        with self.assertRaises(SystemExit):
            python_pure_cdbmake(args, stdin=stdin, stderr=stderr)

        error_msg = stderr.getvalue().lower()
        self.assertIn('record {}'.format(record_number), error_msg)
        self.assertIn(expected_error, error_msg)

    def test_cdbmake_invalid_start(self):
        # Records must start with +
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'-2,2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid start')

    def test_cdbmake_invalid_klen(self):
        # Key length must be terminated by ,
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2;2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid klen')

        # Key length must be an integer
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+0b,2:aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid klen')

    def test_cdbmake_invalid_separator(self):
        # Key and data must be separated by ->
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa>>bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid separator')

    def test_cdbmake_invalid_dlen(self):
        # Data length must be terminated by :
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2;aa->bb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid dlen')

    def test_cdbmake_short_record(self):
        # File cuts off before data
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa->b'
        )
        self._cdbmake_invalid(stdin, 2, 'did not match given length')

    def test_cdbmake_long_record(self):
        # Data too long - should have newline
        stdin = io.BytesIO(
            b'+7,3:integer->241\n'
            b'+2,2:aa->bbb\n'
            b'\n'
        )
        self._cdbmake_invalid(stdin, 2, 'invalid character')

    def test_cdbmake_weird(self):
        # Records can have a newline
        stdin = io.BytesIO(
            b'+2,2:,:->:,\n'
            b'+2,2:->-><-\n'
            b'+7,7:newline->123\n'
            b'567\n'
            b'+2,2:\0+->+\0\n'
            b'\n'
        )
        cdb_path = os.path.join(self.temp_dir, 'out.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp.cdb')
        args = [cdb_path, tmp_path]

        python_pure_cdbmake(args, stdin=stdin)

        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()

        reader = cdblib.Reader(data)
        self.assertEqual(reader[b',:'], b':,')
        self.assertEqual(reader[b'->'], b'<-')
        self.assertEqual(reader[b'newline'], b'123\n567')
        self.assertEqual(reader[b'\0+'], b'+\0')

    def test_cdbmake_64_bits(self):
        # Construct a 64-bit database with the CLI tool and read back the
        # records
        stdin = io.BytesIO(TYPES_DATA)
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        tmp_path = os.path.join(self.temp_dir, 'tmp_64.cdb')
        args = ['-64', cdb_path, tmp_path]
        python_pure_cdbmake(args, stdin=stdin)

        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()
            output_hash = hashlib.md5()
            output_hash.update(data)

        # Ensure that everything can be decoded properly
        with io.open(cdb_path, 'rb') as infile:
            data = infile.read()

        reader = cdblib.Reader64(data)
        self.assertEqual(reader[b'binary'], b'\x81')
        self.assertEqual(reader.getstring(b'text'), u'\U0001f574')
        self.assertEqual(list(reader.getints(b'integer')), [102010, 241])

    def test_cdbdump_known_hash(self):
        # Dump a pre-made file to text and compare the output to what
        # is given by the official cdbdump tool
        top250_path = testdata_path('top250pws.cdb')
        with io.open(top250_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump([], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        # `<top250pws.cdb cdbdump | md5sum` produced the control
        output_hash = hashlib.md5()
        output_hash.update(data)
        self.assertEqual(
            output_hash.hexdigest(), '0564adfe4667506a326ba2f363415616'
        )

    def test_cdbdump_64_bits(self):
        # Construct a 64-bit database and then read it back with the CLI
        # tool. Since the cdbdump is text, the 64-bit database should
        # produce the same input as the 32-bit database
        cdb_path = os.path.join(self.temp_dir, 'out_64.cdb')
        with io.open(cdb_path, 'wb') as outfile:
            writer = cdblib.Writer64(outfile)
            writer.put(b'binary', b'\x81')
            writer.putstring(b'text', u'\U0001f574')
            writer.putint(b'integer', 102010)
            writer.putint(b'integer', 241)
            writer.finalize()

        with io.open(cdb_path, 'rb') as stdin:
            with io.BytesIO() as stdout:
                python_pure_cdbdump(['-64'], stdin=stdin, stdout=stdout)
                data = stdout.getvalue()

        self.assertEqual(data, TYPES_DATA)


if __name__ == '__main__':
    unittest.main()
